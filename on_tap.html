<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ôn tập Lập trình Phân tán</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f0f2f5;
        color: #333;
        line-height: 1.6;
        margin: 0;
        padding: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }
      #quiz-wrapper {
        width: 100%;
        max-width: 900px;
        background-color: #fff;
        padding: 25px 40px;
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      #quiz-header {
        text-align: center;
        border-bottom: 2px solid #0056b3;
        padding-bottom: 10px;
        margin-bottom: 20px;
      }
      h1 {
        color: #0056b3;
        margin: 0;
      }
      #progress-text {
        font-size: 1.1em;
        font-weight: bold;
        color: #555;
      }
      .question-text {
        font-weight: bold;
        font-size: 1.2em;
        margin-bottom: 15px;
      }
      .question-code {
        background-color: #eef;
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 5px;
        font-family: "Courier New", Courier, monospace;
        white-space: pre-wrap;
        margin: 15px 0;
      }
      .question-image {
        max-width: 100%;
        height: auto;
        display: block;
        margin: 15px auto;
        border: 1px solid #ccc;
        border-radius: 5px;
      }
      .option {
        margin-bottom: 10px;
        padding: 12px;
        border-radius: 8px;
        border: 1px solid #ddd;
        display: flex;
        align-items: center;
        cursor: pointer;
        transition: background-color 0.3s;
      }
      .option:hover {
        background-color: #f5f5f5;
      }
      .option label {
        margin-left: 10px;
        width: 100%;
        cursor: pointer;
      }
      .option input {
        flex-shrink: 0;
        cursor: pointer;
      }
      /* --- CSS cho kết quả --- */
      .option.correct {
        background-color: #d4edda;
        border-color: #c3e6cb;
        color: #155724;
      }
      .option.incorrect {
        background-color: #f8d7da;
        border-color: #f5c6cb;
        color: #721c24;
      }
      #feedback-container {
        margin-top: 20px;
        padding: 15px;
        border-radius: 8px;
        font-size: 1.2em;
        font-weight: bold;
        text-align: center;
      }
      .feedback-correct {
        background-color: #d4edda;
        color: #155724;
      }
      .feedback-incorrect {
        background-color: #f8d7da;
        color: #721c24;
      }
      #controls {
        text-align: center;
        margin-top: 25px;
      }
      button {
        color: white;
        padding: 12px 25px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1.1em;
        margin: 0 10px;
        transition: background-color 0.3s;
      }
      #check-btn {
        background-color: #007bff;
      }
      #check-btn:hover {
        background-color: #0056b3;
      }
      #next-btn {
        background-color: #28a745;
      }
      #next-btn:hover {
        background-color: #218838;
      }
      #restart-btn {
        background-color: #6c757d;
      }
      #restart-btn:hover {
        background-color: #5a6268;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="quiz-wrapper">
      <div id="quiz-header">
        <h1>Ôn tập Lập trình Phân tán</h1>
        <div id="progress-text"></div>
      </div>

      <div id="quiz-container"></div>

      <div id="feedback-container" class="hidden"></div>

      <div id="controls">
        <button id="check-btn" onclick="checkAnswer()">Kiểm tra</button>
        <button id="next-btn" class="hidden" onclick="nextQuestion()">
          Câu tiếp theo
        </button>
        <button id="restart-btn" class="hidden" onclick="restartQuiz()">
          Làm lại từ đầu
        </button>
      </div>
    </div>

    <script>
      // --- DỮ LIỆU CÂU HỎI ---
      const quizData = [
        {
          id: 1,
          question:
            "Các tiến trình (Process) trong một hệ thống phân tán gồm nhiều máy tính đặt tại nhiều địa điểm khác nhau giao tiếp với nhau bằng cách nào ? ",
          options: [
            "Không sử dụng mô hình bộ nhớ chia sẻ, cũng như mô hình truyền thông điệp qua mạng truyền thông ",
            "Sử dụng mô hình bộ nhớ chia sẻ ",
            "Sử dụng mô hình truyền thông điệp qua mạng truyền thông ",
          ],
          correctAnswers: [
            "Sử dụng mô hình truyền thông điệp qua mạng truyền thông ",
          ],
        },
        {
          id: 2,
          question:
            "Các luồng (Thread) trong một hệ thống đồng thời dựa trên cơ chế khoá, chạy trên một máy tính gồm nhiều bộ vi xử lý, giao tiếp với nhau bằng cách nào ? ",
          options: [
            "Sử dụng mô hình bộ nhớ chia sẻ ",
            "Không sử dụng mô hình bộ nhớ chia sẻ, cũng như mô hình truyền thông điệp qua mạng truyền thông ",
            "Sử dụng mô hình truyền thông điệp qua mạng truyền thông ",
          ],
          correctAnswers: ["Sử dụng mô hình bộ nhớ chia sẻ "],
        },
        {
          id: 3,
          question:
            "Chương trình đồng thời khác với chương trình tuần tự ở những điểm nào sau đây? ",
          options: [
            "Trong chương trình đồng thời, tại một thời điểm có thể thực hiện nhiều tính toán, trong khi đó với chươngtrình tuần tự, tại một thời điểm chỉ có nhiều nhất 1 tính toán được thực hiện ",
            "Hai kiểu chương trình này không có sự khác biệt nào cả ",
            "Chương trình tuần tự chỉ có 1 luồng thực thi, trong khi đó chương trình đồng thời có nhiều luồng cùng thực thi ",
            "Khi chạy một chương trình đồng thời, có thể xảy ra nhiều kịch bản khác nhau, dẫn đến nhiều kết quả khác nhau ",
          ],
          correctAnswers: [
            "Trong chương trình đồng thời, tại một thời điểm có thể thực hiện nhiều tính toán, trong khi đó với chươngtrình tuần tự, tại một thời điểm chỉ có nhiều nhất 1 tính toán được thực hiện ",
            "Chương trình tuần tự chỉ có 1 luồng thực thi, trong khi đó chương trình đồng thời có nhiều luồng cùng thực thi ",
            "Khi chạy một chương trình đồng thời, có thể xảy ra nhiều kịch bản khác nhau, dẫn đến nhiều kết quả khác nhau ",
          ],
        },
        {
          id: 4,
          question:
            "Cho một chương trình đồng thời gồm có hai luồng P và Q. Luồng P thực hiện hai câu lệnh p1 và p2. Tương tự, luồng Q thực hiện hai câu lệnh q1 và theo sau bởi q2. Những kịch bản (thứ tự của các câu lệnh) nào sau đâu KHÔNG THỂ xảy ra khi chương trình này được thực thi ? ",
          image: "image_question_4.png",
          options: [
            "p1 -> q1 -> p2 -> q2 ",
            "q1 -> p1 -> q2 -> p2 ",
            "p1 -> p2 -> q1 -> q2 ",
            "p1 -> q2 -> p2 -> q1 ",
            "q1 -> p2 -> q2 -> p1 ",
          ],
          correctAnswers: ["p1 -> q2 -> p2 -> q1 ", "q1 -> p2 -> q2 -> p1 "],
        },
        {
          id: 5,
          question:
            "Trạng thái đua tranh (race condition) giữa các luồng trong một chương trình đồng thời dẫn đến những điều nào sau đây? ",
          options: [
            "Tính chính xác của chương trình bị phụ thuộc vào thời gian thực thi tương đối của các sự kiện ",
            "Giá trị của các biến chia sẻ luôn luôn nhất quán và chính xác khi các luồng thực hiện việc cập nhật các biến đó ",
            "Dữ liệu chia sẻ có thể bị mất mát khi các luồng cùng thực hiện việc thay đổi dữ liệu đó ",
          ],
          correctAnswers: [
            "Tính chính xác của chương trình bị phụ thuộc vào thời gian thực thi tương đối của các sự kiện ",
            "Dữ liệu chia sẻ có thể bị mất mát khi các luồng cùng thực hiện việc thay đổi dữ liệu đó ",
          ],
        },
        {
          id: 6,
          question:
            "Chương trình Java sau khi chạy sẽ bao gồm tất cả bao nhiêu luồng ? ",
          code: 'public class HelloThread1 extends Thread{\n    public void run() {\n        for (int i = 0; i < 2; i++)\n            System.out.println(Thread.currentThread().getName() + " - " + i);\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        HelloThread1 t1 = new HelloThread1();\n        HelloThread1 t2 = new HelloThread1();\n        t1.start();\n        t2.start();\n    }\n}',
          options: ["3 ", "2 ", "4 ", "1 "],
          correctAnswers: ["3 "],
        },
        {
          id: 7,
          question:
            "Phương thức hay cơ chế join trong các ngôn ngữ hỗ trợ lập trình đa luồng được dùng trong trường hợp nào sau đây ? ",
          options: [
            "Khi muốn hai luồng T1, T2 có thể thực thi đồng thời ",
            "Khi muốn hai luồng T1, T2 cùng tham gia vào giải quyết một bài toán chung ",
            "Khi muốn một luồng T1 dừng lại và đợi một luồng T2 khác hoàn thành công việc thì T1 mới được thực thi tiếp ",
          ],
          correctAnswers: [
            "Khi muốn một luồng T1 dừng lại và đợi một luồng T2 khác hoàn thành công việc thì T1 mới được thực thi tiếp ",
          ],
        },
        {
          id: 8,
          question:
            "Khi chạy chương trình Java sau có thể sinh ra những kết quả nào sau đây? ",
          code: 'public class Lab1 extends Thread{\n    private int id;\n    public Lab1(int _id) {\n        id = _id;\n    }\n    public void run() {\n        System.out.print("T-" + id + " ");\n    }\n\n    public static void main(String[] args) throws InterruptedException {\n        Lab1 t1 = new Lab1(1);\n        Lab1 t2 = new Lab1(2);\n\n        t1.start();\n        t2.start();\n\n        t1.join();\n        t2.join();\n\n        System.out.print("T-m ");\n    }\n}',
          options: [
            "T-m T-1 T-2 ",
            "T-2 T-1 T-m ",
            "T-m T-2 T-1 ",
            "T-1 T-m T-2 ",
            "T-2 T-m T-1 ",
            "T-1 T-2 T-m ",
          ],
          correctAnswers: ["T-2 T-1 T-m ", "T-1 T-2 T-m "],
        },
        {
          id: 9,
          question:
            "Cho đoạn mã giả của một chương trình đồng thời với luồng t, u như Hình dưới đây. Giả sử các câu lệnh được thực thi một cách nguyên tử. Sau khi hai luồng t, u thực thi xong các câu lệnh của mình, biến chia sẻ counter có thể nhận những giá trị nào sau đây ? ",
          image: "image_question_9.png",
          options: ["3 ", "1 ", "2 ", "0 "],
          correctAnswers: ["1 ", "2 "],
        },
        {
          id: 10,
          question:
            "Trạng thái đua tranh (race condition) của các luồng trong một chương trình đồng thời, liên quan đến việc cập nhật dữ liệu / biến chia sẻ, có thể dẫn đến điều gì sau đây ? ",
          options: [
            "Làm tăng thời gian tính toán của chương trình ",
            "Làm chương trình bị treo ",
            "Làm dữ liệu bị mất mát, hư hỏng, không nhất quán ",
          ],
          correctAnswers: ["Làm dữ liệu bị mất mát, hư hỏng, không nhất quán "],
        },
        {
          id: 11,
          question:
            "Xét thuật toán trong Hình dưới đây để giải quyết bài toán loại trừ lẫn nhau trong một chương trình đồng thời có 2 luồng cùng thực thi. Những kịch bản thực thi nào sau đây của 4 câu lệnh (được đánh số màu đỏ), trong 2 phương thức requestCS(), sẽ khiến cho thuật toán này vi phạm điều kiện loại trừ lẫn nhau, tức là cho phép cả 2 luồng T0 và T1 đều có thể cùng đi vào khu vực quan trọng? ",
          image: "image_question_11.png",
          options: [
            "3->1->4->2 ",
            "1->3->4->2 ",
            "3->4->1->2 ",
            "3->1->2->4 ",
            "1->2->3->4 ",
            "1->3->2->4 ",
          ],
          correctAnswers: [
            "1->3->2->4 ",
            "3->1->4->2 ",
            "1->3->4->2 ",
            "3->1->2->4 ",
          ],
        },
        {
          id: 12,
          question:
            "Xét thuật toán trong Hình dưới để giải quyết bài toán loại trừ lẫn nhau trong một hệ thống đồng thời có 2 luồng cùng hoạt động. Những kịch bản nào sau đây là đúng cho thứ tự đi vào khu vực quan trọng của hai luồng T0, T1 nếu hệ thống sử dụng thuật toán này? ",
          image: "image_question_12.png",
          options: [
            "T1, T0, T1, T0, T1, T0 ",
            "T0, T1, T1, T0, T0, T1 ",
            "T1, T1, T1, T0, T0, T0 ",
            "T0, T1, T0, T1, T0, T1 ",
          ],
          correctAnswers: ["T0, T1, T0, T1, T0, T1 "],
        },
        {
          id: 13,
          question:
            "Xét thuật toán trong Hình dưới để giải quyết bài toán loại trừ lẫn nhau trong một hệ thống đồng thời có 2 luồng cùng hoạt động. Những kịch bản thực thi nào của 4 câu lệnh được đánh dấu màu đỏ, trong 2 phương thức requestCS(), sẽ khiến cho chương trình rơi vào trạng thái khoá chết (deadlock)? ",
          image: "image_question_13.png",
          options: [
            "3->4->2->1 ",
            "1->2->3->4 ",
            "3->1->2->4 ",
            "1->3->2->4 ",
            "3->1->4->2 ",
            "1->3->4->2 ",
          ],
          correctAnswers: ["1->3->2->4 ", "3->1->4->2 "],
        },
        {
          id: 14,
          question:
            "Trong bài toán loại trừ lẫn nhau, khu vực quan trọng CS (Critical Section) của một luồng là gì? ",
          options: [
            "Phần đoạn mã của luồng cần được thực thi một cách nguyên tử (hay được thực thi một cách trọn vẹn, không bị can thiệp bởi luồng khác) ",
            "Phần đoạn mã thực hiện một tính toán quan trọng của luồng ",
            "Phần đoạn mã của luồng chia sẻ với một luồng khác ",
          ],
          correctAnswers: [
            "Phần đoạn mã của luồng cần được thực thi một cách nguyên tử (hay được thực thi một cách trọn vẹn, không bị can thiệp bởi luồng khác) ",
          ],
        },
        {
          id: 15,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về các phương thức trong giao diện Lock, dùng để giải quyết bài toán loại trừ lẫn nhau trong một chương trình đồng thời ? ",
          image: "image_question_15.png",
          options: [
            "Phương thức requestCS() được gọi SAU khi một luồng muốn đi vào khu vực quan trọng ",
            "Phương thức releaseCS() được gọi TRƯỚC khi một luồng đi ra khỏi khu vực quan trọng ",
            "Phương thức requestCS() có mục đích kiểm tra điều kiện đi vào khu vực quan trọng của luồng gọi đã được thoả mãn hay chưa ",
            "Phương thức releaseCS() có mục đích khôi phục / thay đổi trạng thái của hệ thống để cho phép các luồng khác đi vào khu vực quan trọng ",
          ],
          correctAnswers: [
            "Phương thức requestCS() có mục đích kiểm tra điều kiện đi vào khu vực quan trọng của luồng gọi đã được thoả mãn hay chưa ",
            "Phương thức releaseCS() có mục đích khôi phục / thay đổi trạng thái của hệ thống để cho phép các luồng khác đi vào khu vực quan trọng ",
          ],
        },
        {
          id: 16,
          question:
            "Nhược điểm chung của các thuật toán Peterson, Bakery khi được sử dụng để giải quyết bài toán loại trừ lẫn nhau trong các chương trình đồng thời là gì? ",
          options: [
            "Không có nhược điểm gì ",
            "Các luồng phải liên tục kiểm tra xem điều kiện đi vào khu vực quan trọng đã được thoả mãn hay chưa, thông qua vòng lặp. Điều này dẫn đến gây lãng phí chu trình CPU ",
            "Sử dụng các biến chia sẻ, dẫn đến có thể mất mát dữ liệu ",
          ],
          correctAnswers: [
            "Các luồng phải liên tục kiểm tra xem điều kiện đi vào khu vực quan trọng đã được thoả mãn hay chưa, thông qua vòng lặp. Điều này dẫn đến gây lãng phí chu trình CPU ",
          ],
        },
        {
          id: 17,
          question:
            "Xét đoạn mã giả cho thuật toán Bakery của Lamport cho bài toán loại trừ lẫn nhau trong các chương trình đồng thời như hình dưới. Các phát biểu nào sau đây là đúng? ",
          image: "image_question_17.png",
          options: [
            "Điều kiện để một luồng i có thể đi vào khu vực quan trọng là: 1) không có luồng j # i nào thực hiện bước lấy số; VÀ 2) tồn tại k #i sao cho (number[k], k) < (number[i], i) ",
            "Điều kiện để một luồng i có thể đi vào khu vực quan trọng là: 1) không có luồng j # i nào thực hiện bước lấy số; VÀ 2) (number[k], k) > (number[i], i), với mọi k # i ",
            "Thuật toán CHỈ được triển khai trên chương trình đồng thời với số lượng luồng bằng 2 ",
            "Thuật toán có thể được triển khai trên chương trình đồng thời với số lượng luồng bất kỳ lớn hơn 1 ",
          ],
          correctAnswers: [
            "Điều kiện để một luồng i có thể đi vào khu vực quan trọng là: 1) không có luồng j # i nào thực hiện bước lấy số; VÀ 2) (number[k], k) > (number[i], i), với mọi k # i ",
            "Thuật toán có thể được triển khai trên chương trình đồng thời với số lượng luồng bất kỳ lớn hơn 1 ",
          ],
        },
        {
          id: 18,
          question:
            "Cấu trúc đồng bộ Semaphore được đề xuất bởi E. Dijkstra gồm có những thành phần nào sau đây ? ",
          options: [
            "Hàng đợi chứa các luồng đang thực thi ",
            "Hàng đợi chứa các luồng bị chặn/khóa thực thi ",
            "Thao tác P() được thực thi nguyên tử: dùng để thêm luồng gọi vào hàng đợi nếu semaphore không ở trạng thái sẵn sàng ",
            "Thao tác V() được thực thi nguyên tử: dùng để đánh thức một luồng bất kỳ trong hàng đợi ",
            "Biến value (kiểu boolean hoặc kiểu int) để quyết định trạng thái của semaphore ",
          ],
          correctAnswers: [
            "Hàng đợi chứa các luồng bị chặn/khóa thực thi ",
            "Thao tác P() được thực thi nguyên tử: dùng để thêm luồng gọi vào hàng đợi nếu semaphore không ở trạng thái sẵn sàng ",
            "Thao tác V() được thực thi nguyên tử: dùng để đánh thức một luồng bất kỳ trong hàng đợi ",
            "Biến value (kiểu boolean hoặc kiểu int) để quyết định trạng thái của semaphore ",
          ],
        },
        {
          id: 19,
          question:
            "Semaphore đếm (Counting Semaphore) và Semaphore nhị phân (Binary Semaphore) khác nhau ở những điểm nào sau đây ? ",
          options: [
            "Semaphore đếm cho phép nhiều luồng cùng ở trong khu vực quan trọng (CS) trong một thời điểm, trong khi Semaphore nhị phân chỉ cho phép nhiều nhất 1 luồng ở trong CS (tức là loại trừ lần nhau) ",
            "Không có hàng đợi các luồng bị khóa trong Semaphore đếm ",
            "Không có thao tác P() trong Semaphore đếm ",
            "Không có thao tác V() trong Semaphore đếm ",
            "Biến value trong Semaphore đếm có kiểu int, không phải kiểu boolean như trong Semaphore nhị phân ",
          ],
          correctAnswers: [
            "Semaphore đếm cho phép nhiều luồng cùng ở trong khu vực quan trọng (CS) trong một thời điểm, trong khi Semaphore nhị phân chỉ cho phép nhiều nhất 1 luồng ở trong CS (tức là loại trừ lần nhau) ",
            "Biến value trong Semaphore đếm có kiểu int, không phải kiểu boolean như trong Semaphore nhị phân ",
          ],
        },
        {
          id: 20,
          question:
            "Trong thuật toán của Peterson cho bài toán loại trừ lẫn nhau, luồng i được đi vào khu vực quan trọng của nó khi nào? ",
          image: "image_question_20.png",
          options: [
            "Chỉ cần luồng i muốn đi vào khu vực quan trọng là sẽ được đi vào khu vực quan trọng mà không cần quan tâm đến luồng kia ",
            "Khi luồng (1-i) muốn đi vào khu vực quan trọng VÀ hiện tại đang đến lượt (turn) ưu tiên của luồng (1-i) ",
            "Chỉ cần đến lượt (turn) ưu tiên của luồng i là được ",
            "Khi luồng (1-i) không muốn đi vào khu vực quan trọng HOẶC hiện tại không phải lượt (turn) ưu tiên của luồng (1-i) ",
          ],
          correctAnswers: [
            "Khi luồng (1-i) không muốn đi vào khu vực quan trọng HOẶC hiện tại không phải lượt (turn) ưu tiên của luồng (1-i) ",
          ],
        },
        {
          id: 21,
          question:
            "Thuật toán của Peterson cho bài toán loại trừ lẫn nhau trong hệ thống đồng thời thỏa mãn những thuộc tính nào dưới đây? ",
          image: "image_question_21.png",
          options: [
            "Có thể hoạt động được với số lượng luồng bất kỳ lớn hơn 1 ",
            "Tiến triển (progress): nếu một hoặc nhiều luồng đang cố gắng để đi vào CS và không có luồng nào bên trong CS, thì ít nhất một trong các luồng sẽ thành công trong việc đi vào CS ",
            "Không chết đói (starvation-freedom): nếu một luồng đang cố gắng đi vào CS, thì luồng đó cuối cùng phải đi vào CS thành công ",
            "Loại trừ lẫn nhau (mutual exclusion): hai luồng bất kỳ không thể ở trong khu vực quan trọng (CS) tại cùng một thời điểm ",
          ],
          correctAnswers: [
            "Tiến triển (progress): nếu một hoặc nhiều luồng đang cố gắng để đi vào CS và không có luồng nào bên trong CS, thì ít nhất một trong các luồng sẽ thành công trong việc đi vào CS ",
            "Không chết đói (starvation-freedom): nếu một luồng đang cố gắng đi vào CS, thì luồng đó cuối cùng phải đi vào CS thành công ",
            "Loại trừ lẫn nhau (mutual exclusion): hai luồng bất kỳ không thể ở trong khu vực quan trọng (CS) tại cùng một thời điểm ",
          ],
        },
        {
          id: 22,
          question:
            "Ưu điểm của việc sử dụng các cấu trúc đồng bộ (như Semaphore, Monitor) cho bài toán loại trừ lẫn nhau trong các chương trình đồng thời, so với các thuật toán Peterson, Bakery là gì ? ",
          options: [
            "Giải quyết được vấn đề bận chờ (busy-waiting), không gây lãng phí chu trình CPU ",
            "Không có ưu điểm gì hơn so với các thuật toán đó ",
            "Thời gian chạy chương trình nhanh hơn ",
          ],
          correctAnswers: [
            "Giải quyết được vấn đề bận chờ (busy-waiting), không gây lãng phí chu trình CPU ",
          ],
        },
        {
          id: 23,
          question:
            "Trong bài toán Sản xuất và Tiêu thụ, với hai luồng Producer và Consumer hoạt động đồng thời, chúng ta cần đảm bảo những điều kiện đồng bộ nào ? ",
          options: [
            "Điều kiện loại trừ lẫn nhau giữa việc luồng Producer thực hiện việc ghi dữ liệu vào bộ đệm và việc luồng Consumer thực hiện việc lấy dữ liệu ra khỏi bộ đệm ",
            "Điều kiện đồng bộ cho phép hai luồng Producer và Consumer cùng thực hiện việc ghi và lấy dữ liệu đồng thời ",
            "Điều kiện đồng bộ khi bộ đệm rỗng, luồng Consumer phải dừng lại ",
            "Điều kiện đồng bộ khi bộ đệm đầy, luồng Producer phải dừng lại ",
          ],
          correctAnswers: [
            "Điều kiện loại trừ lẫn nhau giữa việc luồng Producer thực hiện việc ghi dữ liệu vào bộ đệm và việc luồng Consumer thực hiện việc lấy dữ liệu ra khỏi bộ đệm ",
            "Điều kiện đồng bộ khi bộ đệm rỗng, luồng Consumer phải dừng lại ",
            "Điều kiện đồng bộ khi bộ đệm đầy, luồng Producer phải dừng lại ",
          ],
        },
        {
          id: 24,
          question:
            "Xét một giải pháp cho bài toán Sản xuất và Tiêu thụ, sử dụng cấu trúc đồng bộ hoá Semaphore, như Hình dưới. Semaphore nhị phân mutex được dùng với mục đích gì? ",
          image: "image_question_24.png",
          options: [
            "Đảm bảo quá trình ghi dữ liệu và lấy dữ liệu được thực thi một cách nguyên tử (tức là loại trừ lẫn nhau) ",
            "Cho phép quá trình ghi dữ liệu và lấy dữ liệu được thực thi đồng thời ",
            "Khoá luồng Producer ",
            "Khoá luồng Consumer ",
          ],
          correctAnswers: [
            "Đảm bảo quá trình ghi dữ liệu và lấy dữ liệu được thực thi một cách nguyên tử (tức là loại trừ lẫn nhau) ",
          ],
        },
        {
          id: 25,
          question:
            "Trong bài toán Người đọc và Người ghi, với n > 1 luồng đọc và m > 1 luồng ghi hoạt động đồng thời, chúng ta cần đảm bảo những điều kiện đồng bộ nào sau đây? ",
          options: [
            "Ràng buộc Đọc-Đọc: Hai luồng đọc không được truy cập đồng thời vào CSDL chia sẻ ",
            "Ràng buộc Đọc-Ghi: Một luồng đọc và một luồng ghi không được truy cập đồng thời vào CSDL chia sẻ ",
            "Ràng buộc Đọc-Đọc: Nhiều luồng đọc có thể đồng thời truy cập CSDL chia sẻ ",
            "Ràng buộc Ghi-Ghi: Hai luồng ghi không được truy cập đồng thời vào CSDL chia sẻ ",
          ],
          correctAnswers: [
            "Ràng buộc Đọc-Ghi: Một luồng đọc và một luồng ghi không được truy cập đồng thời vào CSDL chia sẻ ",
            "Ràng buộc Đọc-Đọc: Nhiều luồng đọc có thể đồng thời truy cập CSDL chia sẻ ",
            "Ràng buộc Ghi-Ghi: Hai luồng ghi không được truy cập đồng thời vào CSDL chia sẻ ",
          ],
        },
        {
          id: 26,
          question:
            "Xét một giải pháp cho bài toán Sản xuất và Tiêu thụ, sử dụng cấu trúc đồng bộ hoá Semaphore, như Hình dưới. Câu lệnh isFull.V() được thực hiện bởi luồng Consumer được dùng với mục đích gì? ",
          image: "image_question_26.png",
          options: [
            "Đánh thức luồng Consumer dậy để tiếp tục thực thi công việc, nếu luồng này đang bị khoá trong hàng đợi của semaphore isEmpty ",
            "Khoá luồng Consumer ",
            "Khoá luồng Producer ",
            "Đánh thức luồng Producer để tiếp tục thực thi công việc, nếu luồng này đang bị khoá trong hàng đợi của semaphore isFull ",
          ],
          correctAnswers: [
            "Đánh thức luồng Producer để tiếp tục thực thi công việc, nếu luồng này đang bị khoá trong hàng đợi của semaphore isFull ",
          ],
        },
        {
          id: 27,
          question:
            "Xét một giải pháp cho bài toán Sản xuất và Tiêu thụ, sử dụng cấu trúc đồng bộ hoá Semaphore, như Hình dưới. Câu lệnh isEmpty.V() được thực hiện bởi luồng Producer được dùng với mục đích gì? ",
          image: "image_question_27.png",
          options: [
            "Đánh thức luồng Consumer dậy để tiếp tục thực thi công việc, nếu luồng này đang bị khoá trong hàng đợi của semaphore isEmpty ",
            "Khoá luồng Producer ",
            "Đánh thức luồng Producer để tiếp tục thực thi công việc, nếu luồng này đang bị khoá trong hàng đợi của semaphore isFull ",
            "Khoá luồng Consumer ",
          ],
          correctAnswers: [
            "Đánh thức luồng Consumer dậy để tiếp tục thực thi công việc, nếu luồng này đang bị khoá trong hàng đợi của semaphore isEmpty ",
          ],
        },
        {
          id: 28,
          question:
            "Cho đoạn mã giả sau, cài đặt giải pháp, sử dụng cấu trúc đồng bộ hoá Monitor, cho bài toán Người đọc - Người ghi, trong đó có n > 2 luồng đọc và m > 2 luồng ghi, cùng tương tác với cơ sở dữ liệu chia sẻ. Nếu các khối lệnh cho việc << GHI DỮ LIỆU VÀO DB>> và << ĐỌC DỮ LIỆU TỪ DB>> được chuyển vào bên trong Monitor (trong khối synchronized) thì điều gì sẽ xảy ra? ",
          image: "image_question_28.png",
          options: [
            "Việc này cho phép nhiều luồng đọc được thực hiện việc đọc dữ liệu từ cơ sở dữ liệu chia sẻ tại một thời điểm bất kỳ ",
            "Việc này sẽ chỉ cho phép nhiều nhất một luồng đọc được thực hiện việc đọc dữ liệu từ cơ sở dữ liệu chia sẻ tại một thời điểm bất kỳ -> không thoả mãn được yêu cầu cho phép nhiều luồng đọc cùng đọc cơ sở dữ liệu chia sẻ ",
            "Thuật toán vẫn hoạt động đúng, thoả mãn 3 yêu cầu đồng bộ của bài toán Người đọc - Người ghi ",
          ],
          correctAnswers: [
            "Việc này sẽ chỉ cho phép nhiều nhất một luồng đọc được thực hiện việc đọc dữ liệu từ cơ sở dữ liệu chia sẻ tại một thời điểm bất kỳ -> không thoả mãn được yêu cầu cho phép nhiều luồng đọc cùng đọc cơ sở dữ liệu chia sẻ ",
          ],
        },
        {
          id: 29,
          question:
            "Xét cài đặt của một giải pháp cho bài toán Người đọc - Người ghi, sử dụng cấu trúc đồng bộ hoá Semaphore, như Hình dưới. Mục đích của dòng lệnh if (numberReaders == 0) wlock.V() được gọi bởi một luồng đọc là gì? ",
          image: "image_question_29.png",
          options: [
            "Nếu đây là luồng đọc cuối cùng đã thực hiện xong việc đọc CSDL chia sẻ thì luồng đọc này sẽ đánh thức một luồng đọc bất kỳ đang bị khoá dậy để thực hiện tiếp công việc ",
            "Nếu đây là luồng đọc cuối cùng đã thực hiện xong việc đọc CSDL chia sẻ thì luồng đọc này sẽ đánh thức một luồng ghi bất kỳ đang bị khoá dậy để thực hiện tiếp công việc ",
            "Khoá một luồng đọc đang muốn vào khu vực quan trọng ",
            "Khoá một luồng ghi đang muốn vào khu vực quan trọng ",
          ],
          correctAnswers: [
            "Nếu đây là luồng đọc cuối cùng đã thực hiện xong việc đọc CSDL chia sẻ thì luồng đọc này sẽ đánh thức một luồng ghi bất kỳ đang bị khoá dậy để thực hiện tiếp công việc ",
          ],
        },
        {
          id: 30,
          question:
            "Cho đoạn mã giả của chương trình đa luồng để giải bài toán Sản xuất và Tiêu thụ (với 1 luồng Sản xuất và 1 luồng Tiêu thụ), sử dụng monitor trong Java, như Hình dưới. Phương thức notify() được gọi bởi luồng Producer, dùng với mục đích gì? ",
          image: "image_question_30.png",
          options: [
            "Không có mục đích gì ",
            "Đánh thức luồng Tiêu thụ (Consumer) ",
            "Đánh thức luồng Sản xuất (Producer) ",
            "Đánh thức cả 2 luồng Sản xuất và Tiêu thụ ",
          ],
          correctAnswers: ["Đánh thức luồng Tiêu thụ (Consumer) "],
        },
        {
          id: 31,
          question:
            "Những phát biểu nào sau đây là đúng về cấu trúc đồng bộ hoá Monitor ? ",
          image: "image_question_31.png",
          options: [
            'Tại một thời điểm, có thể có nhiều hơn 1 luồng chiếm giữ monitor (hay "ở bên trong monitor") ',
            "Monitor hướng đối tượng: mỗi đối tượng, trong các ngôn ngữ lập trình hướng đối tượng, mặc định đi kèm với một monitor ",
            'Trong một thời điểm, chỉ có nhiều nhất một luồng chiếm giữ monitor (hay "ở bên trong monitor") ',
            "Monitor KHÔNG hỗ trợ khái niệm biến điều kiện ",
            "Mỗi biến điều kiện X, được hỗ trợ bởi monitor, định nghĩa các thao tác như: wait, notify/signal, notifyAll/broadcast ",
          ],
          correctAnswers: [
            "Monitor hướng đối tượng: mỗi đối tượng, trong các ngôn ngữ lập trình hướng đối tượng, mặc định đi kèm với một monitor ",
            'Trong một thời điểm, chỉ có nhiều nhất một luồng chiếm giữ monitor (hay "ở bên trong monitor") ',
            "Mỗi biến điều kiện X, được hỗ trợ bởi monitor, định nghĩa các thao tác như: wait, notify/signal, notifyAll/broadcast ",
          ],
        },
        {
          id: 32,
          question:
            "Sự khác nhau giữa hai kiểu monitor (kiểu Hoare và kiểu Mesa), như hình minh hoạ dưới đây, là gì? ",
          image: "image_question_32.png",
          options: [
            "Với monitor kiểu Hoarse, các luồng khi được đánh thức dậy sẽ được chuyển sang hàng đợi s; trong khi với monitor kiểu Mesa, các luồng sau khi được đánh thức dậy sẽ được chuyển về hàng đợi e. ",
            "Với monitor kiểu Mesa (signal-and-continue monitors), khi một luồng đang trong monitor và gọi notify() để đánh thức luồng khác, luồng gọi này sẽ bị tạm dừng và mất quyền chiếm giữ monitor ngay lập tức ",
            "Với monitor kiểu Hoare (signal-and-urgent-wait monitors), khi một luồng đang trong monitor và gọi notify() để đánh thức luồng khác, luồng gọi này sẽ KHÔNG bị mất quyền chiếm giữ monitor ngay, mà nó vẫn tiếp tục công việc của nó cho đến khi hoàn thành và ra khỏi monitor thì luồng được đánh thức lúc này mới có thể chiếm giữ monitor ",
            "Không cần thiết phải có hàng đợi s (cho các luồng được đánh thức) trong monitor kiểu Mesa ",
          ],
          correctAnswers: [
            "Với monitor kiểu Hoarse, các luồng khi được đánh thức dậy sẽ được chuyển sang hàng đợi s; trong khi với monitor kiểu Mesa, các luồng sau khi được đánh thức dậy sẽ được chuyển về hàng đợi e. ",
            "Không cần thiết phải có hàng đợi s (cho các luồng được đánh thức) trong monitor kiểu Mesa ",
          ],
        },
        {
          id: 33,
          question:
            "Xét cài đặt của một giải pháp cho bài toán Người đọc - Người ghi, sử dụng cấu trúc đồng bộ hoá Semaphore, như Hình dưới. Mục đích của dòng lệnh if (numberReaders == 1) wlock.P() được gọi bởi một luồng đọc là gì? ",
          image: "image_question_33.png",
          options: [
            "Đánh thức một luồng đọc bất kỳ đang bị khoá dậy để thực hiện tiếp công việc của nó ",
            "Nếu đây là luồng đọc đầu tiên muốn đi vào khu vực quan trọng thì sẽ chuyển semaphore nhị phân wlock sang trạng thái không sẵn sàng để chặn các luồng ghi phía sau đi vào khu vực quan trọng ",
            "Đánh thức một luồng ghi bất kỳ đang bị khoá dậy để thực hiện tiếp công việc của nó ",
            "Nếu đây là luồng đọc đầu tiên muốn đi vào khu vực quan trọng thì sẽ chuyển semaphore nhị phân wlock sang trạng thái không sẵn sàng để chặn các luồng đọc phía sau đi vào khu vực quan trọng ",
          ],
          correctAnswers: [
            "Nếu đây là luồng đọc đầu tiên muốn đi vào khu vực quan trọng thì sẽ chuyển semaphore nhị phân wlock sang trạng thái không sẵn sàng để chặn các luồng ghi phía sau đi vào khu vực quan trọng ",
          ],
        },
        {
          id: 34,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về Socket được sử dụng để xây dựng ứng dụng phân tán ? ",
          image: "image_question_34.png",
          options: [
            "Socket là một điểm cuối của liên kết truyền thông hai chiều giữa hai tiến trình đang hoạt động trên mạng truyền thông ",
            "Lập trình Socket CHỈ có thể dựa trên giao thức UDP (Universal Datagram Protocol) ",
            "Socket gồm có 2 thành phần: Địa chỉ IP và Cổng ",
            "Socket cung cấp một giao diện ở mức thấp cho việc xây dựng các ứng dụng phân tán ",
          ],
          correctAnswers: [
            "Socket là một điểm cuối của liên kết truyền thông hai chiều giữa hai tiến trình đang hoạt động trên mạng truyền thông ",
            "Socket gồm có 2 thành phần: Địa chỉ IP và Cổng ",
            "Socket cung cấp một giao diện ở mức thấp cho việc xây dựng các ứng dụng phân tán ",
          ],
        },
        {
          id: 35,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về việc sử dụng Socket trên giao thức UDP, hay Data Socket, để xây dựng các ứng dụng phân tán ? ",
          image: "image_question_35.png",
          options: [
            "Hai tiến trình gửi và nhận có thể KHÔNG cần hoạt động tại thời điểm truyền thông điệp ",
            "Tiến trình gửi KHÔNG cần phải biết địa chỉ IP và cổng của tiến trình nhận ",
            "Tiến trình nhận, khi chờ nhận dữ liệu từ tiến trình gửi, sẽ bị chặn lại (block) để chờ nhận đủ dữ liệu thì mới được thực thi tiếp ",
            "Tiến trình gửi không cần phải đảm bảo thông điệp đến phía tiến trình nhận đầy đủ và đúng thứ tự (i.e., thông điệp gửi đi sau có thể đến trước) ",
          ],
          correctAnswers: [
            "Tiến trình nhận, khi chờ nhận dữ liệu từ tiến trình gửi, sẽ bị chặn lại (block) để chờ nhận đủ dữ liệu thì mới được thực thi tiếp ",
            "Tiến trình gửi không cần phải đảm bảo thông điệp đến phía tiến trình nhận đầy đủ và đúng thứ tự (i.e., thông điệp gửi đi sau có thể đến trước) ",
          ],
        },
        {
          id: 36,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về việc sử dụng Socket trên giao thức TCP (hay Stream Socket) để xây dựng các ứng dụng phân tán ? ",
          image: "image_question_36.png",
          options: [
            "Các gói tin được truyền đi tuần tự và phải có xác nhận trả về ",
            "Hai tiến trình gửi và nhận bắt buộc phải hoạt động tại thời điểm truyền thông điệp ",
            "Hai tiến trình gửi và nhận có thể KHÔNG cần hoạt động tại thời điểm truyền thông điệp ",
            "Tiến trình gửi PHẢI biết địa chỉ IP và cổng của tiến trình nhận ",
          ],
          correctAnswers: [
            "Các gói tin được truyền đi tuần tự và phải có xác nhận trả về ",
            "Hai tiến trình gửi và nhận bắt buộc phải hoạt động tại thời điểm truyền thông điệp ",
            "Tiến trình gửi PHẢI biết địa chỉ IP và cổng của tiến trình nhận ",
          ],
        },
        {
          id: 37,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về hai giao thức truyền thông điệp: UDP và TCP ? ",
          options: [
            "TCP là một giao thức kết nối đáng tin cậy, tức là không bị mất gói tin trên đường truyền ",
            "Các gói tin được gửi theo giao thức UDP có thể bị mất trên đường truyền ",
            "TCP KHÔNG đảm bảo thứ tự nhận được của các gói tin giống như thứ tự đã gửi ",
            "Các gói tin được gửi theo giao thức UDP KHÔNG được bảo đảm nhận được theo thứ tự đã gửi ",
          ],
          correctAnswers: [
            "TCP là một giao thức kết nối đáng tin cậy, tức là không bị mất gói tin trên đường truyền ",
            "Các gói tin được gửi theo giao thức UDP có thể bị mất trên đường truyền ",
            "Các gói tin được gửi theo giao thức UDP KHÔNG được bảo đảm nhận được theo thứ tự đã gửi ",
          ],
        },
        {
          id: 38,
          question:
            "Những phát biểu nào sau đây là ĐÚNG khi khái quát về các hệ thống phân tán? ",
          options: [
            "Các tiến trình trong một hệ thống phân tán giao tiếp với nhau bằng cách gửi và nhận thông điệp qua mạng truyền thông ",
            "Luôn tồn tại tài nguyên toàn cục giữa các tiến trình hoạt động trên các máy tính trong một hệ thống phân tán ",
            "Không tồn tại tài nguyên toàn cục giữa các tiến trình hoạt động trên các máy tính trong một hệ thống phân tán ",
            "Các tiến trình trong một hệ thống phân tán luôn biết được trạng thái toàn cục của hệ thống tại bất kỳ thời điểm nào ",
          ],
          correctAnswers: [
            "Các tiến trình trong một hệ thống phân tán giao tiếp với nhau bằng cách gửi và nhận thông điệp qua mạng truyền thông ",
            "Không tồn tại tài nguyên toàn cục giữa các tiến trình hoạt động trên các máy tính trong một hệ thống phân tán ",
          ],
        },
        {
          id: 39,
          question:
            "Những phát biểu nào sau đây là đúng về kỹ thuật RMI (Remote Method Invocations) được sử dụng để xây dựng các ứng dụng phân tán ? ",
          image: "image_question_39.png",
          options: [
            "Hai thành phần đại diện stub và skeleton KHÔNG bắt buộc phải được tạo ra khi thực hiện một lời gọi từ xa ",
            "Kỹ thuật này đòi hỏi phải có 3 kiểu tiến trình: Tiến trình máy khách, Tiến trình máy chủ và RMI Registry ",
            "Tiến trình gửi không cần biết đến vị trí thực sự của đối tượng từ xa ",
            "Mỗi lời gọi từ xa luôn được thực hiện thông qua hai thành phần đại diện: stub ở phía client và skeleton ở phía server ",
          ],
          correctAnswers: [
            "Kỹ thuật này đòi hỏi phải có 3 kiểu tiến trình: Tiến trình máy khách, Tiến trình máy chủ và RMI Registry ",
            "Tiến trình gửi không cần biết đến vị trí thực sự của đối tượng từ xa ",
            "Mỗi lời gọi từ xa luôn được thực hiện thông qua hai thành phần đại diện: stub ở phía client và skeleton ở phía server ",
          ],
        },
        {
          id: 40,
          question:
            "Xét cấu trúc chung của một chương trình MPI như hình bên. Các lời gọi truyền thông điệp có thể được thực hiện ở khu vực nào sau đây? ",
          image: "image_question_40.png",
          options: [
            "Trong khu vực mã tuần tự (serial code) ",
            "Trong khu vực mã song song (parallel code), được đánh dấu bằng các câu lệnh khởi tạo và kết thúc môi trường MPI ",
            "Ở bất kỳ khu vực nào, tuỳ ý ",
          ],
          correctAnswers: [
            "Trong khu vực mã song song (parallel code), được đánh dấu bằng các câu lệnh khởi tạo và kết thúc môi trường MPI ",
          ],
        },
        {
          id: 41,
          question: "MPI hỗ trợ những kiểu truyền thông điệp nào sau đây? ",
          options: [
            "Truyền thông điểm tới điểm (Point to Point communication) ",
            "Truyền thông đa điểm (Collective communication), bao gồm: 1-to-many, many-to-1, many-to-many ",
          ],
          correctAnswers: [
            "Truyền thông điểm tới điểm (Point to Point communication) ",
            "Truyền thông đa điểm (Collective communication), bao gồm: 1-to-many, many-to-1, many-to-many ",
          ],
        },
        {
          id: 42,
          question:
            "Nhược điểm của các kỹ thuật Socket hay RMI/RPC khi sử dụng để xây dựng các ứng dụng phân tán là gì? ",
          options: [
            "Thông thường, tiến trình gửi yêu cầu sẽ bị chặn thực thi cho đến khi nhận được kết quả trả về ",
            "Cả hai kỹ thuật này đều yêu cầu tiến trình gửi phải biết thông tin (địa chỉ IP, cổng) của tiến trình nhận thì mới thực hiện truyền thông được ",
            "Các kỹ thuật này luôn làm chậm quá trình truyền thông giữa hai tiến trình gửi và tiến trình nhận ",
            "Để thực hiện được quá trình truyền thông, tiến trình gửi và tiến trình nhận bắt buộc phải thực thi tại cùng một thời điểm ",
          ],
          correctAnswers: [
            "Thông thường, tiến trình gửi yêu cầu sẽ bị chặn thực thi cho đến khi nhận được kết quả trả về ",
            "Cả hai kỹ thuật này đều yêu cầu tiến trình gửi phải biết thông tin (địa chỉ IP, cổng) của tiến trình nhận thì mới thực hiện truyền thông được ",
            "Để thực hiện được quá trình truyền thông, tiến trình gửi và tiến trình nhận bắt buộc phải thực thi tại cùng một thời điểm ",
          ],
        },
        {
          id: 43,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về MOM (Message-Oriented Middleware) ? ",
          image: "image_question_43.png",
          options: [
            "Luôn có một thành phần trung gian, thường được gọi là Messaging Server / Broker, để điều phối quá trình gửi và nhận các thông điệp ",
            "Để thực hiện được quá trình truyền thông điệp, hai tiến trình gửi và nhận bắt buộc phải thực thi tại cùng một thời điểm ",
            "Các hệ thống dựa trên MOM cho phép việc truyền thông diễn ra thông qua trao đổi bất đồng bộ các thông điệp, i.e., phía gửi và phía nhận có thể không cần hoạt động tại thời điểm truyền thông ",
            "Phía gửi và phía nhận bắt buộc phải biết đến sự tồn tại của nhau (ví dụ: thông tin về địa chỉ IP, cổng, ...) thì quá trình truyền thông điệp mới diễn ra được ",
          ],
          correctAnswers: [
            "Luôn có một thành phần trung gian, thường được gọi là Messaging Server / Broker, để điều phối quá trình gửi và nhận các thông điệp ",
            "Các hệ thống dựa trên MOM cho phép việc truyền thông diễn ra thông qua trao đổi bất đồng bộ các thông điệp, i.e., phía gửi và phía nhận có thể không cần hoạt động tại thời điểm truyền thông ",
          ],
        },
        {
          id: 44,
          question:
            "Những phát biểu nào là ĐÚNG về mô hình truyền thông điệp Xuất bản - Đăng ký (Publish/Subscribe hay Pub/Sub), được hỗ trợ bởi các nền tảng MOM, như hình minh hoạ dưới đây ? ",
          image: "image_question_44.png",
          options: [
            "Trong mô hình này, một thông điệp chỉ được gửi đến duy nhất một tiến trình nhận ",
            "Trong mô hình này, đôi khi không cần đến thành phần Messaging Server ",
            "Trong mô hình này, một chủ đề (topic), khi đã có trên Messaging Server, sẽ được gửi đến tất cả tiến trình đăng ký chủ đề này ",
            "Mô hình này cho phép phía gửi và phía nhận có thể không cần hoạt động cùng một thời điểm mà quá trình truyền thông điệp vẫn diễn ra được ",
          ],
          correctAnswers: [
            "Trong mô hình này, một chủ đề (topic), khi đã có trên Messaging Server, sẽ được gửi đến tất cả tiến trình đăng ký chủ đề này ",
            "Mô hình này cho phép phía gửi và phía nhận có thể không cần hoạt động cùng một thời điểm mà quá trình truyền thông điệp vẫn diễn ra được ",
          ],
        },
        {
          id: 45,
          question:
            "Giả sử: P_i là một tiến trình trong hệ thống phân tán; e_i, f_i, g_i biểu thị các sự kiện đã xảy ra trên các tiến trình. Ký hiệu e → f biểu thị sự kiện e đã xảy ra trước sự kiện f trong mô hình đã-xảy-ra-trước. Ký hiệu e || f biểu thị sự kiện e xảy ra 'đồng thời' với sự kiện f, tức là chúng ta không có đủ thông tin để kết luận sự kiện nào đã xảy ra trước. Cho sơ đồ tiến trình - thời gian dưới đây, những mối liên hệ giữa các sự kiện nào là chính xác ? ",
          image: "image_question_45.png",
          options: [
            "e1 -> f4 ",
            "f2 -> g4 ",
            "f2 -> g2 ",
            "e4 -> f4 ",
            "e3 -> g4 ",
            "e1 || g3 ",
          ],
          correctAnswers: ["f2 -> g4 ", "e1 || g3 "],
        },
        {
          id: 46,
          question:
            "Những phát biểu nào là ĐÚNG về mô hình truyền thông điệp Điểm-tới-Điểm (Point-to-Point), được hỗ trợ bởi các nền tảng MOM, như hình minh hoạ dưới đây? ",
          image: "image_question_46.png",
          options: [
            "Messaging Server sử dụng queue làm nơi lưu trữ. Queue giữ lại các thông điệp cho đến khi tiến trình đích nhận được thông điệp hoặc đến thời gian timout được thiết lập. ",
            "Trong mô hình này, một thông điệp chỉ được gửi đến duy nhất một tiến trình nhận ",
            "Trong mô hình này, cùng một thông điệp có thể được gửi đến nhiều tiến trình nhận ",
            "Trong mô hình này, đôi khi không cần đến thành phần Messaging Server ",
            "Mô hình này cho phép các tiến trình phía gửi và phía nhận có thể không cần hoạt động cùng một thời điểm mà quá trình truyền thông điệp vẫn diễn ra được ",
          ],
          correctAnswers: [
            "Messaging Server sử dụng queue làm nơi lưu trữ. Queue giữ lại các thông điệp cho đến khi tiến trình đích nhận được thông điệp hoặc đến thời gian timout được thiết lập. ",
            "Trong mô hình này, một thông điệp chỉ được gửi đến duy nhất một tiến trình nhận ",
            "Mô hình này cho phép các tiến trình phía gửi và phía nhận có thể không cần hoạt động cùng một thời điểm mà quá trình truyền thông điệp vẫn diễn ra được ",
          ],
        },
        {
          id: 47,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về mô hình đã-xảy-ra-trước (happened-before model), kí hiệu →, được đề xuất bởi Leslie Lamport nhằm giải quyết bài toán đồng bộ đồng hồ trong hệ phân tán ? ",
          options: [
            "Trong mô hình đã-xảy-ra-trước, nếu tồn tại một sự kiện g sao cho e → g và g → f, thì e → f ",
            "Trong mô hình đã-xảy-ra-trước, các tiến trình luôn biết được thứ tự tổng thể trên tập các sự kiện đã xảy ra trong hệ phân tán ",
            "Trong mô hình đã-xảy-ra-trước, nếu e là sự kiện gửi của một thông điệp và f là sự kiện nhận của cùng thông điệp đó, thì e → f ",
            "Trong mô hình đã-xảy-ra-trước, nếu e và f là hai sự kiện xảy ra trên cùng một tiến trình và e xảy ra trước f, thì e → f ",
            "Trong mô hình đã-xảy-ra-trước, các tiến trình chỉ có thể biết được một thứ tự bộ phận trên tập các sự kiện đã xảy ra trong hệ phân tán ",
          ],
          correctAnswers: [
            "Trong mô hình đã-xảy-ra-trước, nếu tồn tại một sự kiện g sao cho e → g và g → f, thì e → f ",
            "Trong mô hình đã-xảy-ra-trước, nếu e là sự kiện gửi của một thông điệp và f là sự kiện nhận của cùng thông điệp đó, thì e → f ",
            "Trong mô hình đã-xảy-ra-trước, nếu e và f là hai sự kiện xảy ra trên cùng một tiến trình và e xảy ra trước f, thì e → f ",
            "Trong mô hình đã-xảy-ra-trước, các tiến trình chỉ có thể biết được một thứ tự bộ phận trên tập các sự kiện đã xảy ra trong hệ phân tán ",
          ],
        },
        {
          id: 48,
          question:
            "Cho sơ đồ tiến trình - thời gian, hoặc sơ đồ đã-xảy-ra-trước, như hình vẽ dưới đây. Sử dụng thuật toán đồng hồ vector để đánh dấu thời gian của các trạng thái cho các tiến trình. Dấu thời gian cho trạng thái cuối cùng của tiến trình P2, sau khi các sự kiện cuối cùng xảy ra, là gì ? ",
          image: "image_question_48.png",
          options: ["(4,2,0) ", "(3,5,0) ", "(0,1,3) ", "(3,4,0) "],
          correctAnswers: ["(3,4,0) "],
        },
        {
          id: 49,
          question:
            "Những phát biểu nào sau đây là đúng về thuật toán đồng hồ vector cho bài toán đồng bộ đồng hồ trong hệ thống phân tán ? ",
          options: [
            "với n là số lượng tiến trình trong hệ thống phân tán ",
            "Một đồng hồ vector v là một ánh xạ từ tập trạng thái S đến N^n (vector của các số tự nhiên) với rằng buộc sau:  ∀ s,t  ∈ S:s→t  ⇔  s.v < t.v ",
            "Thuật toán đồng hồ vector khắc phục được nhược điểm của thuật toán đồng hồ logic với việc cung cấp thông tin hoàn chỉnh (hai chiều) về mối quan hệ đã-xảy-ra-trước ",
            "Một đồng hồ vector v là một ánh xạ từ tập trạng thái S đến N^n (vector của các số tự nhiên) với rằng buộc sau:  ∀ s,t  ∈ S:s→t  ⇒  s.v < t.v ",
          ],
          correctAnswers: [
            "Một đồng hồ vector v là một ánh xạ từ tập trạng thái S đến N^n (vector của các số tự nhiên) với rằng buộc sau:  ∀ s,t  ∈ S:s→t  ⇔  s.v < t.v ",
            "Thuật toán đồng hồ vector khắc phục được nhược điểm của thuật toán đồng hồ logic với việc cung cấp thông tin hoàn chỉnh (hai chiều) về mối quan hệ đã-xảy-ra-trước ",
          ],
        },
        {
          id: 50,
          question:
            "Những phát biểu nào sau đây là đúng về thuật toán đồng hồ logic, dùng để lưu vết mối quan hệ thứ tự giữa các sự kiện đã xảy ra trong một hệ thống phân tán? ",
          options: [
            "Ký hiệu e → f biểu thị sự kiện e xảy ra trước sự kiện f trong mô hình đã-xảy-ra-trước. ",
            "Kí hiệu C(e), C(f) là hai số nguyên dương được gán cho hai sự kiện e,f đã xảy ra, nếu C(e) < C(f) thì chúng ta có thể kết luận rằng e -> f ",
            "Trong thuật toán này, mỗi sự kiện, hoặc trạng thái, của một tiến trình được gán với một số nguyên dương để biểu thị dấu thời gian của sự kiện, hoặc trạng thái, đó ",
            "Giả sử E là tập các sự kiện đã xảy ra, đồng hồ logic được định nghĩa là một ánh xạ C từ tập E sang tập các số nguyên dương N, sao cho: ∀𝑒 , 𝑓∈𝐸 : 𝑒 → 𝑓⇒𝐶 ( 𝑒 )< 𝐶 ( 𝑓 ) ",
          ],
          correctAnswers: [
            "Trong thuật toán này, mỗi sự kiện, hoặc trạng thái, của một tiến trình được gán với một số nguyên dương để biểu thị dấu thời gian của sự kiện, hoặc trạng thái, đó ",
            "Giả sử E là tập các sự kiện đã xảy ra, đồng hồ logic được định nghĩa là một ánh xạ C từ tập E sang tập các số nguyên dương N, sao cho: ∀𝑒 , 𝑓∈𝐸 : 𝑒 → 𝑓⇒𝐶 ( 𝑒 )< 𝐶 ( 𝑓 ) ",
          ],
        },
        {
          id: 51,
          question:
            "Cho sơ đồ tiến trình - thời gian, hoặc sơ đồ đã-xảy-ra-trước, như hình vẽ dưới đây. Sử dụng thuật toán đồng hồ logic để đánh dấu thời gian của các trạng thái cho các tiến trình. Dấu thời gian của các trạng thái cuối cùng, sau khi các sự kiện cuối cùng xảy ra, trong sơ đồ của ba tiến trình P1, P2, P3 tương ứng là gì? ",
          image: "image_question_51.png",
          options: ["4, 5, 3 ", "3, 4, 5 ", "1, 2, 3 ", "5, 4, 3 "],
          correctAnswers: ["4, 5, 3 "],
        },
        {
          id: 52,
          question:
            "Cho sơ đồ tiến trình - thời gian, hoặc sơ đồ đã-xảy-ra-trước, như hình vẽ dưới đây. Sử dụng thuật toán đồng hồ phụ-thuộc-trực-tiếp để đánh dấu thời gian của các trạng thái cho các tiến trình. Dấu thời gian cho trạng thái cuối cùng của tiến trình P2, sau khi các sự kiện cuối cùng xảy ra, là gì ? ",
          image: "image_question_52.png",
          options: ["(4,2,0) ", "(3,5,0) ", "(3,4,0) ", "(0,1,3) "],
          correctAnswers: ["(3,5,0) "],
        },
        {
          id: 53,
          question:
            "Những phát biểu nào sau đây là đúng về thuật toán đồng hồ phụ-thuộc-trực-tiếp cho bài toán đồng bộ đồng hồ trong hệ thống phân tán ? ",
          options: [
            "với n là số lượng tiến trình trong hệ thống phân tán ",
            "Một đồng hồ phụ thuộc trực tiếp thoả mãn rằng buộc sau:  ∀ s,t  ∈ S: s→t  ⇔  s.v < t.v ",
            "Thuật toán đồng hồ phụ-thuộc-trực-tiếp là một biến thể của thuật toán đồng hồ vector, trong đó mỗi tiến trình gửi vẫn gắn thêm cả vector để gửi cùng với thông điệp ",
            "Một đồng hồ phụ thuộc trực tiếp thoả mãn rằng buộc sau:  ∀𝑠 , 𝑡 : 𝑠 .𝑝 ≠ 𝑡 . 𝑝 :  𝑠 →_ 𝑑   𝑡   ⇔   𝑠 .𝑣 [ 𝑠 . 𝑝 ] ≤  𝑡 . 𝑣 [ 𝑠 .𝑝 ] ",
            "Thuật toán đồng hồ phụ-thuộc-trực-tiếp là một phiên bản yếu hơn của thuật toán đồng hồ vector, trong đó mỗi tiến trình gửi chỉ gắn thêm 1 số nguyên (là phần tử có chỉ số tương ứng với định danh của tiến trình gửi) để gửi cùng với thông điệp ",
          ],
          correctAnswers: [
            "Một đồng hồ phụ thuộc trực tiếp thoả mãn rằng buộc sau:  ∀𝑠 , 𝑡 : 𝑠 .𝑝 ≠ 𝑡 . 𝑝 :  𝑠 →_ 𝑑   𝑡   ⇔   𝑠 .𝑣 [ 𝑠 . 𝑝 ] ≤  𝑡 . 𝑣 [ 𝑠 .𝑝 ] ",
            "Thuật toán đồng hồ phụ-thuộc-trực-tiếp là một phiên bản yếu hơn của thuật toán đồng hồ vector, trong đó mỗi tiến trình gửi chỉ gắn thêm 1 số nguyên (là phần tử có chỉ số tương ứng với định danh của tiến trình gửi) để gửi cùng với thông điệp ",
          ],
        },
        {
          id: 54,
          question:
            "Những phát biểu nào sau đây là đúng về thuật toán đồng hồ ma trận cho bài toán đồng bộ đồng hồ trong hệ thống phân tán ? ",
          options: [
            "Trong thuật toán này, khi được giá trị đồng hồ W gửi cùng với thông điệp từ một tiến trình khác, tiến trình nhận sẽ tiến hành cập nhật đồng hồ M của nó theo 3 bước: 1) cập nhật các hàng khác với định danh của tiến trình nhận; 2) cập nhật hàng tương ứng với định danh của tiến trình nhận; 3) cập nhật phần tử có hàng và cột tương ứng với định danh của tiến trình nhận. ",
            "Trong thuật toán này, khi gửi thông điệp sang tiến trình khác, một tiến trình sẽ đính kèm với thông điệp một vector, là hàng tương ứng với định danh của tiến trình gửi trong ma trận. ",
            "Đồng hồ ma trận giúp biểu thị mức độ hiểu biết cao hơn so với đồng hồ vector. ",
            "Giá trị M[i,j] của tiến trình P_k thể hiện độ hiểu biết của tiến trình P_k về 'mức độ hiểu biết của tiến trình P_i về tiến trình P_j'. ",
          ],
          correctAnswers: [
            "Trong thuật toán này, khi được giá trị đồng hồ W gửi cùng với thông điệp từ một tiến trình khác, tiến trình nhận sẽ tiến hành cập nhật đồng hồ M của nó theo 3 bước: 1) cập nhật các hàng khác với định danh của tiến trình nhận; 2) cập nhật hàng tương ứng với định danh của tiến trình nhận; 3) cập nhật phần tử có hàng và cột tương ứng với định danh của tiến trình nhận. ",
            "Đồng hồ ma trận giúp biểu thị mức độ hiểu biết cao hơn so với đồng hồ vector. ",
            "Giá trị M[i,j] của tiến trình P_k thể hiện độ hiểu biết của tiến trình P_k về 'mức độ hiểu biết của tiến trình P_i về tiến trình P_j'. ",
          ],
        },
        {
          id: 55,
          question:
            "Xét các bước sau trong Thuật toán của Lamport cho bài toán truy cập tài nguyên chia sẻ trong hệ thống phân tán. Đâu là thứ tự đúng của các bước trong thuật toán này ? Với giả thiết không có lỗi trong hệ thống phân tán, các bộ xử lý và liên kết giao tiếp là tin cậy ! ",
          options: [
            "A, C, B, D ",
            "B, A, C, D ",
            "A, B, D, C ",
            "B, A, D, C ",
            "A, B, C, D ",
          ],
          notes: {
            A: "Khi một tiến trình P_k nhận được thông điệp request từ tiến trình P_i: P_k lưu yêu cầu này & dấu thời gian của nó trong hàng đợi. Sau đó, P_k gửi ngược lại thông điệp ack (xác nhận), có gắn dấu thời gian, cho P_i ",
            B: "Khi tiến trình P_i muốn đi vào CS: P_i gửi thông điệp request có gắn dấu thời gian tới tất cả tiến trình khác. Đồng thời, P_i thêm yêu cầu này, cùng với dấu thời gian, vào trong hàng đợi của P_i ",
            C: "Để giải phóng CS, tiến trình P_i gửi thông điệp release tới tất cả tiến trình khác. Khi một tiến trình P_k nhận được thông điệp release từ P_i, P_k xoá yêu cầu tương ứng của P_i khỏi hàng đợi của P_k ",
            D: "Một tiến trình P_i tự nhận thấy có thể đi vào CS khi và chỉ khi thoả mãn 2 điều kiện sau: 1) P_i đã có yêu cầu trong hàng đợi của P_i với dấu thời gian t nhỏ hơn tất cả các yêu cầu khác đang trong hàng đợi của P_i; 2) P_i đã nhận được thông điệp xác nhận từ tất cả tiến trình khác với dấu thời gian lớn hơn t ",
          },
          correctAnswers: ["B, A, D, C "],
        },
        {
          id: 56,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về Thuật toán của Lamport cho bài toán truy cập tài nguyên chia sẻ trong hệ thống phân tán ? ",
          options: [
            "Thuật toán KHÔNG thỏa mãn thuộc tính Tiến triển, tức là mỗi yêu cầu đi vào khu vực quan trọng cuối cùng phải được cấp quyền để đi vào khu vực quan trọng ",
            "Thuật toán này thoả mãn thuộc tính An toàn, tức là đảm bảo hai tiến trình không được phép truy cập tài nguyên chia sẻ cùng lúc ",
            "Một tiến trình P_i nhận thấy nó có thể đi vào CS nếu:  ∀𝑗 ≠ 𝑖 :( 𝑞 [ 𝑖 ], 𝑖 )<( 𝑞 [ 𝑗 ], 𝑗 ) ∧ ( 𝑞 [ 𝑖 ], 𝑖 )<( 𝑣 [ 𝑗 ], 𝑗 ), trong đó q[i], q[j]: dấu thời gian của yêu cầu đi vào CS của hai tiến trình P_i, P_j và v[j] là dấu thời gian của thông điệp ack từ tiến trình P_j được ghi nhận ở tiến trình P_i ",
            "Thuật toán sử dụng 3*(N-1) thông điệp cho mỗi lần truy cập khu vực quan trọng, với N là số lượng tiến trình, bao gồm: N - 1 thông điệp request, N - 1 thông điệp ack, N - 1 thông điệp release ",
            "Thuật toán đảm bảo rằng các tiến trình đi vào khu vực quan trọng theo thứ tự dấu thời gian của yêu cầu, tức là thoả mãn thuộc tính Công bằng. ",
          ],
          correctAnswers: [
            "Thuật toán này thoả mãn thuộc tính An toàn, tức là đảm bảo hai tiến trình không được phép truy cập tài nguyên chia sẻ cùng lúc ",
            "Thuật toán sử dụng 3*(N-1) thông điệp cho mỗi lần truy cập khu vực quan trọng, với N là số lượng tiến trình, bao gồm: N - 1 thông điệp request, N - 1 thông điệp ack, N - 1 thông điệp release ",
            "Thuật toán đảm bảo rằng các tiến trình đi vào khu vực quan trọng theo thứ tự dấu thời gian của yêu cầu, tức là thoả mãn thuộc tính Công bằng. ",
          ],
        },
        {
          id: 57,
          question:
            "Đâu là một số so sánh ĐÚNG giữa thuật toán của Lamport và thuật toán của Ricart-Agrawala (RA) cho bài toán truy cập tài nguyên chia sẻ trong hệ phân tán? ",
          options: [
            "Trong thuật toán của RA, một tiến trình, khi nhận được thông điệp yêu cầu truy cập tài nguyên chia sẻ, không phải lúc nào cũng gửi thông điệp về cho tiến trình yêu cầu. ",
            "Với thuật toán của Lamport, tiến trình nhận được yêu cầu sẽ luôn gửi thông điệp xác nhận về cho tiến trình gửi yêu cầu. ",
            "Thuật toán của RA không thoả mãn thuộc tính công bằng, giống như thuật toán của Lamport. ",
            "Thuật toán của RA chỉ sử dụng 2*(N-1) thông điệp cho một lần 1 tiến trình truy cập tài nguyên chia sẻ, thay vì 3*(N-1) thông điệp như trong thuật toán của Lamport. ",
            "Với N là số lượng tiến trình trong hệ thống phân tán. ",
            "Trong thuật toán của RA, điều kiện một tiến trình được truy cập tài nguyên chia sẻ giống với thuật toán của Lamport. Tức là: tiến trình gửi yêu cầu đã nhận được N-1 thông điệp xác nhận từ tất cả các tiến trình khác và yêu cầu của tiến trình này có dấu thời gian là nhỏ nhất trong số các yêu cầu ",
          ],
          correctAnswers: [
            "Trong thuật toán của RA, một tiến trình, khi nhận được thông điệp yêu cầu truy cập tài nguyên chia sẻ, không phải lúc nào cũng gửi thông điệp về cho tiến trình yêu cầu. ",
            "Với thuật toán của Lamport, tiến trình nhận được yêu cầu sẽ luôn gửi thông điệp xác nhận về cho tiến trình gửi yêu cầu. ",
            "Thuật toán của RA chỉ sử dụng 2*(N-1) thông điệp cho một lần 1 tiến trình truy cập tài nguyên chia sẻ, thay vì 3*(N-1) thông điệp như trong thuật toán của Lamport. ",
          ],
        },
        {
          id: 58,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về bài toán truy cập tài nguyên chia sẻ, hay bài toán loại trừ lẫn nhau, trong hệ phân tán ? ",
          options: [
            "Với giả thiết không có lỗi trong hệ thống phân tán, các bộ xử lý và liên kết giao tiếp là tin cậy ! ",
            "Có thể sử dụng cách tiếp cận dùng các vòng lặp (ví dụ: while) để chặn một tiến trình truy cập tài nguyên chia sẻ khi điều kiện để vào CS của tiến trình đó chưa được thoả mãn ",
            "Có thể sử dụng Semaphore cho bài toán truy cập tài nguyên chia sẻ trong một hệ thống phân tán ",
            "Có thể sử dụng Monitor cho bài toán truy cập tài nguyên chia sẻ trong một hệ thống phân tán ",
            "Do không có tài nguyên toàn cục trong hệ phân tán, nên không thể sử dụng các cấu trúc đồng bộ hoá như Semaphore hoặc Monitor cho bài toán này ",
          ],
          correctAnswers: [
            "Có thể sử dụng cách tiếp cận dùng các vòng lặp (ví dụ: while) để chặn một tiến trình truy cập tài nguyên chia sẻ khi điều kiện để vào CS của tiến trình đó chưa được thoả mãn ",
            "Do không có tài nguyên toàn cục trong hệ phân tán, nên không thể sử dụng các cấu trúc đồng bộ hoá như Semaphore hoặc Monitor cho bài toán này ",
          ],
        },
        {
          id: 59,
          question:
            "Những phát biểu nào sau đây là ĐÚNG về Thuật toán của Ricart & Agrawala (RA) cho bài toán truy cập tài nguyên chia sẻ trong hệ phân tán ? ",
          options: [
            "Một tiến trình P_i nhận thấy nó có thể đi vào CS nếu P_i đã nhận được N-1 thông điệp okay từ N-1 tiến trình khác đồng ý cho yêu cầu đi vào CS của nó, trong đó N là số lượng tiến trình trong hệ thống phân tán ",
            "Thuật toán sử dụng 2*(N-1) thông điệp cho mỗi lần truy cập khu vực quan trọng, với N là số lượng tiến trình, bao gồm: N-1 thông điệp request, N-1 thông điệp okay ",
            "Thuật toán này KHÔNG thỏa mãn thuộc tính sự sống (liveness), tức là: mỗi yêu cầu đi vào khu vực quan trọng cuối cùng phải được cấp quyền để đi vào khu vực quan trọng ",
            "Trong thuật toán này, một tiến trình không phải lúc nào cũng gửi ngược lại một thông điệp okay khi nhận được một yêu cầu đi vào khu vực quan trọng của tiến trình khác ",
          ],
          correctAnswers: [
            "Một tiến trình P_i nhận thấy nó có thể đi vào CS nếu P_i đã nhận được N-1 thông điệp okay từ N-1 tiến trình khác đồng ý cho yêu cầu đi vào CS của nó, trong đó N là số lượng tiến trình trong hệ thống phân tán ",
            "Thuật toán sử dụng 2*(N-1) thông điệp cho mỗi lần truy cập khu vực quan trọng, với N là số lượng tiến trình, bao gồm: N-1 thông điệp request, N-1 thông điệp okay ",
            "Trong thuật toán này, một tiến trình không phải lúc nào cũng gửi ngược lại một thông điệp okay khi nhận được một yêu cầu đi vào khu vực quan trọng của tiến trình khác ",
          ],
        },
        {
          id: 60,
          question:
            "Xét bài toán truy cập tài nguyên chia sẻ, hay bài toán loại trừ lẫn nhau, trong hệ phân tán. Đâu là một số lớp thuật toán, cách tiếp cận, có thể được sử dụng để giải quyết bài toán này ? ",
          options: [
            "Lớp thuật toán sử dụng các cấu trúc đồng bộ hoá (như Semaphore, Monitor) để giải quyết xung đột trong việc truy cập tài nguyên chia sẻ. ",
            "Lớp thuật toán sử dụng dấu thời gian, gắn với mỗi yêu cầu tài nguyên, để giải quyết xung đột trong việc truy cập tài nguyên chia sẻ. ",
            "Lớp thuật toán sử dụng tài nguyên phụ, token, để giải quyết xung đột trong việc truy cập tài nguyên chia sẻ. ",
            "Các thuật toán này phải đảm bảo tại một thời điểm bất kỳ chỉ có một tài nguyên phụ tồn tại trong hệ thống phân tán và chỉ có một tiến trình nắm giữ tài nguyên phụ này. ",
          ],
          correctAnswers: [
            "Lớp thuật toán sử dụng dấu thời gian, gắn với mỗi yêu cầu tài nguyên, để giải quyết xung đột trong việc truy cập tài nguyên chia sẻ. ",
            "Lớp thuật toán sử dụng tài nguyên phụ, token, để giải quyết xung đột trong việc truy cập tài nguyên chia sẻ. ",
          ],
        },
      ];

      // --- LOGIC JAVASCRIPT ---

      // Các biến trạng thái của bài quiz
      let currentQuestionIndex = 0;
      let score = 0;

      // Lấy các phần tử DOM
      const quizContainer = document.getElementById("quiz-container");
      const feedbackContainer = document.getElementById("feedback-container");
      const progressText = document.getElementById("progress-text");
      const checkBtn = document.getElementById("check-btn");
      const nextBtn = document.getElementById("next-btn");
      const restartBtn = document.getElementById("restart-btn");

      // Hàm để tải câu hỏi hiện tại
      function loadCurrentQuestion() {
        // Xóa nội dung câu hỏi cũ và phản hồi
        quizContainer.innerHTML = "";
        feedbackContainer.classList.add("hidden");

        // Lấy dữ liệu câu hỏi hiện tại
        const questionData = quizData[currentQuestionIndex];

        // Cập nhật thanh tiến trình
        progressText.innerText = `Câu ${currentQuestionIndex + 1} / ${
          quizData.length
        }`;

        // Tạo HTML cho câu hỏi
        let questionHTML = `<div class="question-text">${questionData.question}</div>`;
        if (questionData.image) {
          questionHTML += `<img src="images/${questionData.image}" alt="Hình ảnh cho câu ${questionData.id}" class="question-image">`;
        }
        if (questionData.code) {
          questionHTML += `<pre class="question-code"><code>${questionData.code}</code></pre>`;
        }

        // Tạo HTML cho các lựa chọn
        const inputType =
          questionData.correctAnswers.length > 1 ? "checkbox" : "radio";
        const optionsHTML = questionData.options
          .map(
            (option) => `
        <div class="option">
            <input type="${inputType}" name="q${
              questionData.id
            }" value="${option.trim()}">
            <label>${option}</label>
        </div>
    `
          )
          .join("");

        quizContainer.innerHTML =
          questionHTML + `<div id="options-container">${optionsHTML}</div>`;

        // Reset trạng thái các nút
        checkBtn.classList.remove("hidden");
        nextBtn.classList.add("hidden");
      }

      // Hàm để kiểm tra câu trả lời
      function checkAnswer() {
        const questionData = quizData[currentQuestionIndex];
        const selectedInputs = quizContainer.querySelectorAll("input:checked");

        // Kiểm tra xem người dùng đã chọn đáp án chưa
        if (selectedInputs.length === 0) {
          alert("Bạn vui lòng chọn một đáp án!");
          return;
        }

        // Lấy các đáp án người dùng đã chọn
        let userAnswers = [];
        selectedInputs.forEach((input) => userAnswers.push(input.value));

        // So sánh với đáp án đúng
        const correctAnswers = questionData.correctAnswers
          .map((ans) => ans.trim())
          .sort();
        userAnswers.sort();
        const isCorrect =
          JSON.stringify(userAnswers) === JSON.stringify(correctAnswers);

        // Hiển thị phản hồi
        feedbackContainer.classList.remove("hidden");
        if (isCorrect) {
          score++;
          feedbackContainer.textContent = "Chính xác! Tuyệt vời!";
          feedbackContainer.className = "feedback-correct";
        } else {
          feedbackContainer.textContent =
            "Không chính xác. Hãy xem lại đáp án đúng.";
          feedbackContainer.className = "feedback-incorrect";
        }

        // Tô màu các đáp án và vô hiệu hóa input
        const allOptions = quizContainer.querySelectorAll(".option");
        allOptions.forEach((optionDiv) => {
          const input = optionDiv.querySelector("input");
          input.disabled = true; // Vô hiệu hóa để không chọn lại được
          if (correctAnswers.includes(input.value)) {
            optionDiv.classList.add("correct");
          } else if (input.checked) {
            optionDiv.classList.add("incorrect");
          }
        });

        // Cập nhật trạng thái các nút
        checkBtn.classList.add("hidden");
        nextBtn.classList.remove("hidden");
      }

      // Hàm để chuyển sang câu hỏi tiếp theo
      function nextQuestion() {
        currentQuestionIndex++;
        if (currentQuestionIndex < quizData.length) {
          loadCurrentQuestion();
        } else {
          showResults();
        }
      }

      // Hàm để hiển thị kết quả cuối cùng
      function showResults() {
        quizContainer.innerHTML = `
        <div style="text-align:center; font-size: 1.5em;">
            <p>🎉 Hoàn thành bài kiểm tra! 🎉</p>
            <p>Số điểm của bạn là: <strong>${score} / ${quizData.length}</strong></p>
        </div>
    `;
        progressText.innerText = "Kết quả";
        feedbackContainer.classList.add("hidden");
        checkBtn.classList.add("hidden");
        nextBtn.classList.add("hidden");
        restartBtn.classList.remove("hidden");
      }

      // Hàm để bắt đầu lại
      function restartQuiz() {
        currentQuestionIndex = 0;
        score = 0;
        restartBtn.classList.add("hidden");
        loadCurrentQuestion();
      }

      // Bắt đầu bài quiz khi trang được tải
      window.onload = loadCurrentQuestion;
    </script>
  </body>
</html>
